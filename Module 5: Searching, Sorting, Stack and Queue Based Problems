1. Array, Key, Segment, Search:
------------------------------------------
Given an array arr[] and size of array is n (not more than 10) and one another key x, and given you a segment size k. 
The task is to find that the key x present in every segment of size k in arr [].
Print "Yes the key found in every segment" if the key is present. else print "No Key not found in every segment"

Input Format: enter the size of the array n
enter the array elements in the second line
enter the key value x in the third line
enter the segment size k in the fourth line.

output: print the array values and yes/no if key is present in the array.

first line enter x value which indicates key

Test case example:
------------------------------
case=t1
fail message="hidden test case"
input=
9
3 6 2 2 5 7 4 5 2
3
3
output=No Key not found in every segment

case=t2
fail message="hidden test case"
input=
9
6 7 2 5 2 9 4 3 2
2
3
output=Yes the key found in every segment

case=t3
input=5
2 1 3 5 1
1
2
output=No Key not found in every segment

case=t4
input=5
2 1 1 5 1
1
4
output=Yes the key found in every segment

case=t5
input=7
10 40 20 30 40 20 20
20
3
output=Yes the key found in every segment

PROGRAM:
------------------------------
import java.util.Scanner;

public class Main {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // System.out.print("Enter the size of the array: ");
        int n = scanner.nextInt();
        int[] arr = new int[n];
        // System.out.println("Enter the array elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        // System.out.print("Enter the key value: ");
        int x = scanner.nextInt();
        // System.out.print("Enter the segment size: ");
        int k = scanner.nextInt();
        int result = isKeyPresentInSegments(arr, n, x, k);
        System.out.println("Array values:");
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
        if (result == 1) {
            System.out.println("Yes the key found in every segment");
        } else {
            System.out.println("No Key not found in every segment");
        }
        scanner.close();
    }

    public static int isKeyPresentInSegments(int arr[], int n, int x, int k) {
        if (k <= 0 || k > n) {
            return 0;
        }
        for (int i = 0; i < n; i += k) {
            int found = 0;
            for (int j = i; j < i + k && j < n; j++) {
                if (arr[j] == x) {
                    found = 1;
                    break;
                }
            }
            if (found == 0) {
                return 0;
            }
        }
        return 1;
    }
}

2. Smaller < X < Greater:
-------------------------------
Find the element in the array before which all the elements are smaller than it, and after 
which all are greater than it.
Return the index of the element if at all there is such an element, otherwise, return No element found.

Array size not more than 10.

Test case example:
------------------------------
case=t1
fail message="hidden test case"
input=
7
2 1 3 4 6 5 10
output=
Index of the element: 2

case=t2
input=10
2 1 3 4 5 7 12 45 78 10
output=
Index of the element: 2

case=t3
input=5
1 2 5 4 8
output=Index of the element: 1

case=t4
input=5
10 2 2 3 1 0
output=No such element found.

case=t5
fail message="hidden test case where size of array is 1"
input=1
1
output=No such element found.

PROGRAM:
----------------------------------
import java.util.Scanner;

public class Main {
    
    public static int check(int[] arr, int n, int ind) {
        int i = ind - 1;
        int j = ind + 1;

        while (i >= 0) {
            if (arr[i] > arr[ind]) {
                return 0;
            }
            i--;
        }

        while (j < n) {
            if (arr[j] < arr[ind]) {
                return 0;
            }
            j++;
        }

        return 1;
    }

    public static int findElement(int[] arr, int n) {
        for (int i = 1; i < n - 1; i++) {
            if (check(arr, n, i) == 1) {
                return i;
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();
        int[] arr = new int[n];

        System.out.println("Enter the elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int index = findElement(arr, n);
        if (index != -1) {
            System.out.println("Index of the element: " + index);
        } else {
            System.out.println("No such element found");
        }

        scanner.close();
    }
}

3. Efficient Bubble Sort:
------------------------------------
Write a java program to do optimized bubble sort.

use the following logic to complete program
------------------------------------------

for i from 0 to n-1
    flag = false

    for j from 0 to n-i-1
        if arr[j] > arr[j+1]
            swap arr[j] and arr[j+1]
            flag = true

       if flag is false
        break from the loop
    else
      for j from 0 to n:
     print pass output arr[j]
     
 back to main loop

Test Case example
--------------------
case=t1
input=5
2 1 3 4 5
Pass 1: 1 2 3 4 5 
output=
Sorted array is:
 1 2 3 4 5 

case=t2
input=7
34 21 67 45 123 43 89
output=
Pass 1: 21 34 45 67 43 89 123 
Pass 2: 21 34 45 43 67 89 123 
Pass 3: 21 34 43 45 67 89 123 
Sorted array is:
21 34 43 45 67 89 123 

case=t3
fail message="hidden test case with negative numbers size of array is 6"
input=6
23 -10 65 12 89 32
Pass 1: -10 23 12 65 32 89 
Pass 2: -10 12 23 32 65 89 
output=Sorted array is:
 -10 12 23 32 65 89 
 
case=t4
input=6
3 1 6 8 10 56
Pass 1: 1 3 6 8 10 56 
output=
Sorted array is:
 1 3 6 8 10 56 

PROGRAM:
-------------------------
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();
        int[] arr = new int[n];

        System.out.println("Enter the elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int temp;
        boolean flag;
        for (int i = 0; i < n - 1; i++) {
            flag = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }

            System.out.print("Pass " + (i + 1) + ": ");
            for (int k = 0; k < n; k++) {
                System.out.print(arr[k] + " ");
            }
            System.out.println();
        }

        System.out.println("Sorted array is:");
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }

        scanner.close();
    }
}

4. Insertion Sort with passes after each iteration:
--------------------------------------------------------------
Write a java program to implement Insertion sort with passes.

Test Cases:
---------------------------------
case = t1
input = 5
12 78 45 2 18
output = 

THE  UNSORTED LIST
12	78	45	2	18	
PASS - 1 :12	78	45	2	18	
PASS - 2 :12	45	78	2	18	
PASS - 3 :2	12	45	78	18	
PASS - 4 :2	12	18	45	78	

THE  SORTED LIST - INSERTION SORT
2	12	18	45	78	

case = t2
input = 8
9 8 7 6 5 4 3 2
output =

THE  UNSORTED LIST
9	8	7	6	5	4	3	2	
PASS - 1 :8	9	7	6	5	4	3	2	
PASS - 2 :7	8	9	6	5	4	3	2	
PASS - 3 :6	7	8	9	5	4	3	2	
PASS - 4 :5	6	7	8	9	4	3	2	
PASS - 5 :4	5	6	7	8	9	3	2	
PASS - 6 :3	4	5	6	7	8	9	2	
PASS - 7 :2	3	4	5	6	7	8	9	

THE  SORTED LIST - INSERTION SORT
2	3	4	5	6	7	8	9	

case = t3
input = 5
2 50 1 3 40
output = 

THE  UNSORTED LIST
2	50	1	3	40	
PASS - 1 :2	50	1	3	40	
PASS - 2 :1	2	50	3	40	
PASS - 3 :1	2	3	50	40	
PASS - 4 :1	2	3	40	50	

THE  SORTED LIST - INSERTION SORT
1	2	3	40	50	

PROGRAM:
-------------------------------
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
         System.out.println("THE UNSORTED LIST:");
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
        insertionSort(arr, n);
        System.out.println("THE SORTED LIST - INSERTION SORT");
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
        scanner.close();
    }

    public static void insertionSort(int[] arr, int n) {
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
            printArray(arr, n, i);
        }
    }

    public static void printArray(int[] arr, int n, int pass) {
        System.out.print("Pass " + pass + ": ");
        for (int k = 0; k < n; k++) {
            System.out.print(arr[k] + " ");
        }
        System.out.println();
    }
}

5. Merge two Unsorted arrays into Ascending order:
------------------------------------------------------
Write a Java program to Merge two Unsorted arrays into Ascending order 

Input format: enter size of array 1 followed by elements.
similary size of array 2 and followed by elements.

Condition: size of merged array not more than 20.

Note: use the function definitions given below.

Test case example:
-----------------
case=t1
input=5
2 1 6 7 5
7
20 10 34 15 4 12 78
output=
Final Sorted array is: 
1 2 4 5 6 7 10 12 15 20 34 78 

case=t2
fail message="hidden test case"
input=
7
0 2 1 5 4 8 7
4
7 8 2 1
output=
Final Sorted array is:
0 1 1 2 2 4 5 7 7 8 8 

PROGRAM:
--------------------------------------
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int size1 = scanner.nextInt();
        int[] arr1 = new int[size1];
        for (int i = 0; i < size1; i++) {
            arr1[i] = scanner.nextInt();
        }
        
        int size2 = scanner.nextInt();
        int[] arr2 = new int[size2];
        for (int i = 0; i < size2; i++) {
            arr2[i] = scanner.nextInt();
        }

        if (size1 + size2 > 20) {
            System.out.println("Merged array size exceeds the limit of 20.");
        } else {
            int[] mergedArray = mergeAndSort(arr1, arr2);
            System.out.print("Final Sorted array is: ");
            for (int num : mergedArray) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
        scanner.close();
    }

    public static int[] mergeAndSort(int[] arr1, int[] arr2) {
        int[] merged = new int[arr1.length + arr2.length];
        int index = 0;
        for (int num : arr1) {
            merged[index++] = num;
        }
        for (int num : arr2) {
            merged[index++] = num;
        }
        Arrays.sort(merged);
        return merged;
    }
}


6. Quick Sort with Last element as pivot:
---------------------------------------------
Write a java program to implement quick sort by considering last element as pivot element.

Apply the following algorithm:
--------------------------------
1. Read the value of n from input.
2. Create a new array with size 10.
3. For i = 0 to n - 1, do:
     Read a[i] from input.
4. Call the quicksort(a, 0, n - 1) function.
5. For i = 0 to n - 1:
     Print a[i].
     
6. quicksort(a, left, right):
   If left < right, then:
       Set pivot = partition(a, left, right).
       Call quicksort(a, left, pivot - 1).
       Call quicksort(a, pivot + 1, right).
      
7. partition(a, left, right):
   Set pivot = a[right].
   Set i = left - 1.
   For j = left to right - 1:
      If a[j] <= pivot, then:
           Increment i by 1.
           Swap a[i] and a[j].
   Swap a[i + 1] and a[right].
   Return i + 1.

sample test case:
-------------------
case=t1
input=5
3 1 8 4 5
output=3 1 4 5 8 
3 1 4 
1 3 
1 3 4 5 8 

case=t2
fail message="hidden case"
input=7
2 1 8 3 10 67 45
output=
2 1 8 3 10 45 67 
2 1 8 3 10 
2 1 3 8 
1 2 
1 2 3 8 10 45 67 


case=t3
input=4
5 4 3 1
output=
1 4 3 5 
4 3 5 
3 4 
1 3 4 5 


Explaination: After first iteration, pivot element 1 is exchanged with 5.
              After the first recursive call, pivot element 5 is exchanged with itself and output is: 4 3 5
              After the second recursive call, pivot element 3 is exchanged with 4 and output of array is: 3 4
At the end of all recursive calls, the final array output is 1 3 4 5

PROGRAM:
--------------------
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[10];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }

        quicksort(a, 0, n - 1);
        
        for (int i = 0; i < n; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
        scanner.close();
    }

    public static void quicksort(int[] a, int left, int right) {
        if (left < right) {
            int pivot = partition(a, left, right);
            quicksort(a, left, pivot - 1);
            quicksort(a, pivot + 1, right);
        }
    }

    public static int partition(int[] a, int left, int right) {
        int pivot = a[right];
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (a[j] <= pivot) {
                i++;
                swap(a, i, j);
            }
        }
        swap(a, i + 1, right);
        
        printArray(a, left, right); // Print the array after partitioning
        return i + 1;
    }

    public static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    public static void printArray(int[] a, int left, int right) {
        for (int i = left; i <= right; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
    }
}


//taking firsrt element as pivor
// import java.util.Scanner;

// public class Main {
//     public static void main(String[] args) {
//         Scanner scanner = new Scanner(System.in);
//         int n = scanner.nextInt();
//         int[] a = new int[10];
//         for (int i = 0; i < n; i++) {
//             a[i] = scanner.nextInt();
//         }

//         quicksort(a, 0, n - 1);
        
//         for (int i = 0; i < n; i++) {
//             System.out.print(a[i] + " ");
//         }
//         System.out.println();
//         scanner.close();
//     }

//     public static void quicksort(int[] a, int left, int right) {
//         if (left < right) {
//             int pivot = partition(a, left, right);
//             quicksort(a, left, pivot - 1);
//             quicksort(a, pivot + 1, right);
//         }
//     }

//     public static int partition(int[] a, int left, int right) {
//         int pivot = a[left];
//         int i = left + 1;
//         for (int j = left + 1; j <= right; j++) {
//             if (a[j] <= pivot) {
//                 swap(a, i, j);
//                 i++;
//             }
//         }
//         swap(a, left, i - 1); // Place pivot at the correct position
        
//         printArray(a, left, right); // Print the array after partitioning
//         return i - 1; // Return the index of the pivot
//     }

//     public static void swap(int[] a, int i, int j) {
//         int temp = a[i];
//         a[i] = a[j];
//         a[j] = temp;
//     }

//     public static void printArray(int[] a, int left, int right) {
//         for (int i = left; i <= right; i++) {
//             System.out.print(a[i] + " ");
//         }
//         System.out.println();
//     }
// }


7. Median of 2 Sorted Arrays:
-------------------------------------
Given two sorted arrays nums1 and nums2 of size m and n respectively,
return the median of the two sorted arrays.

median is calculated as follows:
The idea is to merge them into third array and there are two cases:

Case 1: If the length of the merged array is odd, then the median is at (length)/2 index 
Case 2: If the length of the merged array is even, then the median will be 
        the average of elements at index ((length)/2 ) and ((length)/2 – 1) 

condition: merged Array size not more than 20.

Test case example:
----------------------------
case=t1
fail message="hidden test case"
input=5
2 4 6 7 8
5
1 2 6 9 10
output=
Merged Array: 
1 2 2 4 6 6 7 8 9 10
Median: 6

case=t2
input=6
1 2 6 9 10 23
4 
1 2 3 4
output=
Merged Array: 
1 1 2 2 3 4 6 9 10 23 
Median: 3


case=t3
fail message="Hidden"
input=
7
3 7 8 12 45 67 89
4
34 67 78 120
output=
Merged Array: 
3 7 8 12 34 45 67 67 78 89 120 
Median: 45

PROGRAM:
-----------------------------------
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int[] nums1 = new int[m];
        for (int i = 0; i < m; i++) {
            nums1[i] = scanner.nextInt();
        }
        int n = scanner.nextInt();
        int[] nums2 = new int[n];
        for (int i = 0; i < n; i++) {
            nums2[i] = scanner.nextInt();
        }

        int[] mergedArray = merge(nums1, nums2, m, n);
        System.out.print("Merged Array: ");
        printArray(mergedArray, m + n);
        
        double median = findMedian(mergedArray, m + n);
        System.out.println("Median: " + (int)median);
        
        scanner.close();
    }

    public static int[] merge(int[] nums1, int[] nums2, int m, int n) {
        int[] mergedArray = new int[m + n];
        int i = 0, j = 0, k = 0;
        while (i < m && j < n) {
            if (nums1[i] <= nums2[j]) {
                mergedArray[k++] = nums1[i++];
            } else {
                mergedArray[k++] = nums2[j++];
            }
        }
        while (i < m) {
            mergedArray[k++] = nums1[i++];
        }
        while (j < n) {
            mergedArray[k++] = nums2[j++];
        }
        return mergedArray;
    }

    public static double findMedian(int[] mergedArray, int length) {
        if (length % 2 == 1) {
            return mergedArray[length / 2];
        } else {
            return (mergedArray[length / 2] + mergedArray[length / 2 - 1]) / 2.0;
        }
    }

    public static void printArray(int[] array, int length) {
        for (int i = 0; i < length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}

8. Find the Ceil of a key in the Array:
----------------------------------------------
Given a sorted array in ascending order and a value key, 
the ceiling of key is the smallest element in array greater than or equal to key.
Write a java program to find ceiling of a given key in the sorted array.

/*
Algorithm: findCeil(arr[], low, high, x)
   Input Array arr[] with indices low and high, and element x to search
   1. If x <= arr[low], return low as the ceil
   2. loop from i = low to high:
      a. If arr[i] == x, return i as the ceil 
      b. If arr[i] < x and arr[i + 1] >= x, return i + 1 as the ceil
   3. Return -1 to indicate that the ceil is not found in the array.   */

TEST CASES:
-------------------------
case=t1
fail message="hidden test case"
input=6
1 2 3 5 6 7
4
output=
The ceiling of 4 is: 5


case=t2
input=7
1 2 3 4 4 5 7
7
output=The ceiling of 7 is: 7

case=t3
input=1
23
10
output=The ceiling of 10 is: 23

case=t4
input=6
1 1 2 3 6 5
0
output=The ceiling of 0 is: 1

case=t5
input=7
1 2 3 5 7 8 10
34
output=No ceiling for the number 34 exists in array. 

PROGRAM:
----------------------------
import java.util.Scanner;

public class Main{
    public static int findCeil(int[] arr, int low, int high, int x) {
        if (x <= arr[low]) {
            return low;
        }
        for (int i = low; i < high; i++) {
            if (arr[i] == x) {
                return i;
            }
            if (arr[i] < x && arr[i + 1] >= x) {
                return i + 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int key = scanner.nextInt();
        
        int result = findCeil(arr, 0, n - 1, key);
        if (result != -1) {
            System.out.println("The ceiling of " + key + " is: " + arr[result]);
        } else {
            System.out.println("No ceiling for the number " + key + " exists in array.");
        }
        
        scanner.close();
    }
}


9. Find the Floor of a key in the Array:
---------------------------------------------------
Given a sorted array in ascending order and a value key, 
the floor of key is the greater element in the array less than or equal to key.
Write a java program to find floor of a given key in the sorted array.

TEST CASES:
------------------------------
case=t1
fail message="hidden test case"
input=6
1 2 3 5 6 7
4
output=
The floor of 4 is: 3


case=t2
input=7
1 2 3 4 4 5 7
7
output=The floor of 7 is: 7

case=t3
input=1
23
10
output=No floor value for number 10 exists in the array

case=t4
input=6
1 1 2 3 6 5
0
output=No floor value for number 0 exists in the array


case=t5
input=7
1 2 3 5 7 8 10
34
output=The floor of 34 is: 10

PROGRAM:
--------------------------------
import java.util.Scanner;

public class Main {
    public static int findFloor(int[] arr, int n, int key) {
        if (key < arr[0]) {
            return -1;
        }
        
        for (int i = n - 1; i >= 0; i--) {
            if (arr[i] <= key) {
                return arr[i];
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int key = scanner.nextInt();
        
        int result = findFloor(arr, n, key);
        if (result != -1) {
            System.out.println("The floor of " + key + " is: " + result);
        } else {
            System.out.println("No floor value for number " + key + " exists in the array");
        }
        
        scanner.close();
    }
}

10. Find Minimum Element In the Stack
-------------------------------------------------
Write a java program to find minimum element in the stack.(max size 4)
Implement menu driven program to do the same:
1.Push 2.Pop 3.Display 4.Find Min element 5.exit.

TEST CASES:
-------------------------------
case=t1
fail message="hidden case"
input=
1
9 
1
2
1
4
1
9
3
2
2
3
4
5
output=
Current stack elements are:
9
4
2
9
Popped element is: 9
Popped element is: 4
Current stack elements are:
2
9
Minimum element: 2

case=t2
input=2 5
output=stack underflow

case=t3
input=1 2 1 0 1 5
2 2 2 4 5
output=Popped element is: 5
Popped element is: 0
Popped element is: 2
Stack is empty-There is no Minimum value!!

case=t4
input=1
4
1
5
1
0
1
56
1
3
3
4
5
output=Stack Overflow!!
Current stack elements are:
56
0
5
4
Minimum element: 0


case=t5
input=1
2
3
2
3
4
5
output=
Current stack elements are:
2
Popped element is: 2
Stack is empty!!
Stack is empty-There is no Minimum value!!

PROGRAM:
-------------------------------
import java.util.Scanner;

class Stack {
    private int maxSize = 4;
    private int[] stackArray = new int[maxSize];
    private int top = -1;

    public void push(int value) {
        if (top < maxSize - 1) {
            stackArray[++top] = value;
       
        } else {
            System.out.println("Stack overflow!!");
        }
    }

    public int pop() {
        if (top >= 0) {
            return stackArray[top--];
        } else {
            System.out.println("Stack underflow");
            return -1;
        }
    }

    public void display() {
        if (top >= 0) {
            System.out.println("Current stack elements are:");
            for (int i = top; i >= 0; i--) {
                System.out.println(stackArray[i]);
            }
        } else {
            System.out.println("Stack is empty");
        }
    }

    public Integer findMin() {
        if (top < 0) {
            System.out.println("Stack is empty-There is no Minimum Value!!");
            return null;
        }
        int min = stackArray[0];
        for (int i = 1; i <= top; i++) {
            if (stackArray[i] < min) {
                min = stackArray[i];
            }
        }
        return min;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Stack stack = new Stack();
        int choice;

        do {
            // System.out.println("Menu:");
            // System.out.println("1. Push");
            // System.out.println("2. Pop");
            // System.out.println("3. Display");
            // System.out.println("4. Find Min Element");
            // System.out.println("5. Exit");
            // System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    // System.out.print("Enter value to push: ");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case 2:
                    int poppedValue = stack.pop();
                    if (poppedValue != -1) {
                        System.out.println("Popped element is: " + poppedValue);
                    }
                    break;
                case 3:
                    stack.display();
                    break;
                case 4:
                    Integer min = stack.findMin();
                    if (min != null) {
                        System.out.println("Minimum element: " + min);
                    }
                    break;
                case 5:
                    break;
                default:
                    System.out.println("Invalid choice");
            }
        } while (choice != 5);

        scanner.close();
    }
}

//better approach search time is o(1)

import java.util.Scanner;
import java.util.Stack;

public class MinStack {
    private static final int SIZE = 4;
    private int[] mainStack = new int[SIZE];
    private int[] minStack = new int[SIZE];
    private int top = -1;
    private int minTop = -1;

    public void push(int x) {
        if (top == SIZE - 1) {
            System.out.println("Stack Overflow!!");
            return;
        } else {
            top++;
            mainStack[top] = x;
        }

        if (minTop == -1 || x <= minStack[minTop]) {
            minTop++;
            minStack[minTop] = x;
        }
    }

    public int pop() {
        if (top == -1) {
            System.out.println("Stack underflow");
            return -1;
        }

        int element = mainStack[top];
        System.out.println("Popped element is: " + element);
        top--;

        if (element == minStack[minTop]) {
            minTop--;
        }

        return element;
    }

    public void getMin() {
        if (minTop == -1) {
            System.out.println("Stack is empty - There is no Minimum value!!");
            return;
        }

        System.out.println("Minimum Element: " + minStack[minTop]);
    }

    public void show() {
        if (top == -1) {
            System.out.println("Stack is empty!!");
            return;
        }

        System.out.println("Current stack elements are:");
        for (int i = top; i >= 0; i--) {
            System.out.println(mainStack[i]);
        }
    }

    public static void main(String[] args) {
        MinStack stack = new MinStack();
        Scanner scanner = new Scanner(System.in);
        int choice;

        while (true) {
            System.out.println("\n1. Push the element");
            System.out.println("2. Pop the element");
            System.out.println("3. Show stack elements");
            System.out.println("4. Find Minimum");
            System.out.println("5. Exit");
            System.out.print("Enter the choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter the element to be added onto the stack: ");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case 2:
                    stack.pop();
                    break;
                case 3:
                    stack.show();
                    break;
                case 4:
                    stack.getMin();
                    break;
                case 5:
                    System.exit(0);
                default:
                    System.out.println("Invalid choice!!");
            }
        }
    }
}


11. Well Formed Paranthesis:
------------------------------------
 A bracket is considered to be any one of the following characters: (, ), {, }, [, or ]. 
Two brackets are considered to be a well formed if the an opening bracket (i.e., (, [, or {)
occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type.
There are three types of matched pairs of brackets: [], {}, and ().
A matching pair of brackets is not balanced if the set of brackets it encloses are not matched.
For example, {[(])} is not balanced because 
the contents in between { and } are not balanced. 
The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single,
unbalanced closing square bracket, ].

Write a java program to check for well formed paranthesis.

Constraint: The maximum characters that can be stored in stack is upto 10.

TEST CASES:
------------------
case=t1
input=(){}
output=Well Formed Parenthesis

case=t2
input=((({})))
output=Well Formed Parenthesis

case=t3
input={}[(]}
output=Not Well Formed Parenthesis

case=t4
input={]}
output=Not Well Formed Parenthesis

case=t5
input=()()()()()()()()()()()()
output=Well Formed Parenthesis

case=t6
input=((((([[[[[[
output=Not Well Formed Parenthesis

case=t7
fail message="hidden"
input={()}
output=Well Formed Parenthesis

PROGRAM:
------------------------
import java.util.Scanner;

public class Main {
    static final int MAX_SIZE = 10;
    char[] stack = new char[MAX_SIZE];
    int top = -1;

    void push(char ch) {
        if (top < MAX_SIZE - 1) {
            stack[++top] = ch;
        }
    }

    char pop() {
        if (top != -1) {
            return stack[top--];
        }
        return '\0'; // Return null character if stack is empty
    }

  
    boolean isWellFormed(String expression) {
        for (char ch : expression.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                push(ch);
            } else if (ch == ')' || ch == '}' || ch == ']') {
                if (top==-1) {
                    return false; // Unmatched closing bracket
                }
                char topChar = pop();
                if (!isMatchingPair(topChar, ch)) {
                    return false; // Mismatched pair
                }
            }
        }
        return top==-1; // If stack is empty, parentheses are well formed
    }

    boolean isMatchingPair(char opening, char closing) {
        return (opening == '(' && closing == ')') || 
               (opening == '{' && closing == '}') || 
               (opening == '[' && closing == ']');
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // System.out.println("Enter the expression to check:");
        String expression = scanner.nextLine();
        Main checker = new Main();

        if (checker.isWellFormed(expression)) {
            System.out.println("Well Formed Parenthesis");
        } else {
            System.out.println("Not Well Formed Parenthesis");
        }
        scanner.close();
    }
}


12. Infix to Postfix with Invalid expression cases.
--------------------------------------------------------------
Write a java program to convert infix expression into postfix expression.

Algorithm:
----------------
1. First Start scanning the expression(max length 20) from left to right
2. If the scanned character is an operand, output it, i.e. print it
3. Else
   3.1 If the precedence of the scanned operator is higher than the precedence of the operator in the stack.
       (or stack is empty or has '('), then push operator in the stack.
   3.2 Else, Pop all the operators, that have greater or equal precedence than the scanned operator. 
       Once you pop them push this scanned operator. (If we see a opening parenthesis while popping then stop 
       and push scanned operator in the stack)
4. If the scanned character is an  '(', push it to the stack.
5. If the scanned character is an  ')', pop the stack and output it until a '(' is encountered, and discard both the parenthesis.
6. Now, we should repeat the steps 2 – 5 until the whole characters are scanned.
7. Print output
8. Do the pop and output (print) until stack is not empty

Note: The expression should include only opening and closing braces i.e ( and ).
      if any other brace exists in expression. print appropriate error message given in testcase.
      Expression should be well formed expression. check the testcases given.
      Include these constraints while developing the program along with the given algorithm.

TEST CASES:
------------------
case=t1
input=(a+b)*c
output=Postfix expression is : ab+c*

case=t2
input=a+b*c/d-f+a^e
output=Postfix expression is : abc*d/+f-ae^+

case=t3
fail message="hidden test case"
input=(a+B-E)+{1-]
output=Invalid Infix Expression-Different parenthesis in expression

case=t4
input=(a+b
output=Invalid Infix Expression - missing close brace

case=t5
input=a+b)
output=Invalid Infix Expression - missing open brace

case=t6
input=(a+b)-(c*d)
output=Postfix expression is : ab+cd*-

case=t7
input=(a+b)-c*d)
output=Invalid Infix Expression - missing open brace

case=t8
input=(a+b-)
output=Invalid Infix Expression - operators and operands doesnot match

case=t9
input=(a+b}
output=Invalid Infix Expression-Different parenthesis in expression

case=t10
fail message="hidden test case check operator and operand count"
input=(a+b--c)
output=Invalid Infix Expression - operators and operands doesnot match       

PROGRAM:
--------------------------------

import java.util.Scanner;
import java.util.Stack;

public class Main {
    static final int MAX = 20;
    char[] stack = new char[MAX];
    int top = -1;
    String infix;
    StringBuilder postfix = new StringBuilder();

    public static void main(String[] args) {
        Main converter = new Main();
        converter.inputInfixExpression();
    }

    void inputInfixExpression() {
        Scanner scanner = new Scanner(System.in);
        infix = scanner.next();
        int flag = toPostfix(infix);
        if (flag == 1) {
            System.out.println("Postfix expression is : " + postfix);
        } else {
            System.out.println("Invalid Infix Expression - operators and operands doesnot match");
            System.exit(0);
        }
        scanner.close();
    }

    int toPostfix(String infix) {
        char temp;
        int operatorCount = 0;
        int operandCount = 0;

        for (int i = 0; i < infix.length(); i++) {
            char ch = infix.charAt(i);
            if (ch == '(') {
                push(ch);
            } else if (Character.isLetterOrDigit(ch)) {
                operandCount++;
                postfix.append(ch);
            } else if (ch == '^' || ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%') {
                operatorCount++;
                while (top != -1 && getPriority(stack[top]) >= getPriority(ch)) {
                    postfix.append(pop());
                }
                push(ch);
            } else if (ch == ')') {
                while (top != -1 && stack[top] != '(') {
                    postfix.append(pop());
                }
                if (top != -1) {
                    temp = pop(); // pop the '('
                } else {
                    System.out.println("Invalid Infix Expression - missing open brace");
                               System.exit(0);
                }
            } else {
                System.out.println("Invalid Infix Expression - Different parenthesis in expression");
                           System.exit(0);
            }
        }

        while (top != -1) {
            char ch = pop();
            if (ch == '(') {
                System.out.println("Invalid Infix Expression - missing close brace");
                            System.exit(0);;
            }
            postfix.append(ch);
        }

        if (operatorCount == operandCount - 1) {
            return 1; // valid expression
        } else {
            return 0; // invalid expression
        }
    }

    void push(char element) {
        if (top == MAX - 1) {
            System.out.println("Stack overflow");
        } else {
            stack[++top] = element;
        }
    }

    char pop() {
        if (top == -1) {
            System.out.println("Invalid Infix Expression - missing open brace");
            System.exit(0);
         
        } 
            return stack[top--];
    }

    int getPriority(char op) {
        if (op == '^') return 2;
        else if (op == '/' || op == '*' || op == '%') return 1;
        else if (op == '+' || op == '-') return 0;
        else return -1;
    }
}

13. Delete Elements upto Nth Position in Queue:
-----------------------------------------------
Write a java program to elements upto Nth position from the queue using menu driven approach. 

Assume size of the queue is 5:

Menu consists of following operations:
-------------------------------------------------
1 Enqueue element into the end of the queue. 
2 Dequeue the elements at the front of the queue upto given Nth Position. (enter choice and then enter Nth position)
3 Display the elements of the queue
4 EXIT.

Use the following messages for printing approriate errors:
"Queue Overflow!!" during enqueue
"Queue Underflow!!" while deleting the elements.
"Queue is Empty" while displaying the elements.

Test case examples:
---------------------
case=t1
input=1
20
1
30
1
40
3
2
2
3
4
output=
Enqueued(20)
Enqueued(30)
Enqueued(40)
Queue is:
20  30  40  
Dequeued(20)
Dequeued(30)
Queue is:
40  

case=t2
input=1
20
1
30
1
40
3
2
3
3
4
output=
Enqueued(20)
Enqueued(30)
Enqueued(40)
Queue is:
20  30  40  
Dequeued(20)
Dequeued(30)
Dequeued(40)
Queue is Empty

case=t3
input=5 4
output=invalid choice!!

case=t4
input=2
4
output=Queue Underflow!!

case=t5
input=3
4
output=Queue is Empty

case=t6
fail message="hidden"
input=
1
20
1
30
1
40
1
50
3
2
2
3
4
output=
Enqueued(20)
Enqueued(30)
Enqueued(40)
Enqueued(50)
Queue is:
20  30  40  50  
Dequeued(20)
Dequeued(30)
Queue is:
40  50

PROGRAM:
-------------------------
import java.util.Scanner;

public class Main {
    static final int SIZE = 5;
    int[] queue = new int[SIZE];
    int front = -1;
    int rear = -1;

    public static void main(String[] args) {
       Main q = new Main();
        q.menu();
    }

    void menu() {
        Scanner scanner = new Scanner(System.in);
        int choice;

        while (true) {
            // System.out.println("\nMenu:");
            // System.out.println("1. Enqueue");
            // System.out.println("2. Dequeue up to Nth Position");
            // System.out.println("3. Display Queue");
            // System.out.println("4. EXIT");
            // System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    // System.out.print("Enter element to enqueue: ");
                    int element = scanner.nextInt();
                    enqueue(element);
                    break;
                case 2:
                    // System.out.print("Enter Nth position to dequeue: ");
                    int n = scanner.nextInt();
                    dequeue(n);
                    break;
                case 3:
                    display();
                    break;
                case 4:
                    scanner.close();
                    return;
                default:
                    System.out.println("invalid choice!!");
            }
        }
    }

    void enqueue(int element) {
        if ((rear + 1) % SIZE == front) {
            System.out.println("Queue Overflow!!");
            return;
        }
        if (front == -1) {
            front = 0;
        }
        rear = (rear + 1) % SIZE;
        queue[rear] = element;
        System.out.println("Enqueued(" + element + ")");
    }

    void dequeue(int n) {
        if (front == -1) {
            System.out.println("Queue Underflow!!");
            System.exit(0);
        }
        int count = 0;
        while (count < n && front != -1) {
            System.out.println("Dequeued(" + queue[front] + ")");
            front = (front + 1) % SIZE;
            count++;
            if (front == (rear + 1) % SIZE) {
                front = -1;  // Reset front if the queue becomes empty
                rear = -1;   // Reset rear
            }
        }
    }

    void display() {
        if (front == -1) {
            System.out.println("Queue is Empty");
            return;
        }
        System.out.print("Queue is: ");
        int i = front;
        while (i != rear) {
            System.out.print(queue[i] + "  ");
            i = (i + 1) % SIZE;
        }
        System.out.print(queue[rear]);  // Print the last element
        System.out.println();
    }
}

14. Evaluation fo Postfix Expression:
----------------------------------------------
Write a java program to evaluate postfix expression.
(consider only arithmetic operators)

TEST CASES:
------------------
case = t1
input = abc+-
2 3 4
output = -5

case =t2
input = ab+cd+*
2 4 1 3
output = 24

case =t3
input = abc*+d-
2 3 1 9
output = -4

case =t4
input = abc*
2 3 1 
output = invalid postfix expression

case =t5
input = abc*def+
2 3 1 5 6 7
output = invalid postfix expression

PROGRAM:
-------------------------------
import java.util.Scanner;
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        evaluatePostfix();
    }

    public static void evaluatePostfix() {
        Scanner scanner = new Scanner(System.in);
        Stack<Integer> stack = new Stack<>();
        
        String postfix = scanner.nextLine();

        for (int i = 0; i < postfix.length(); i++) {
            char ch = postfix.charAt(i);

            if (isOperand(ch)) {
                int x = scanner.nextInt();
                stack.push(x);
            } else if (isOperator(ch)) {
                int a = stack.pop();
                int b = stack.pop();
                int c = 0;

                switch (ch) {
                    case '+':
                        c = b + a;
                        break;
                    case '-':
                        c = b - a;
                        break;
                    case '*':
                        c = b * a;
                        break;
                    case '/':
                        c = b / a;
                        break;
                    case '%':
                        c = b % a;
                        break;
                    case '^':
                        c = (int) Math.pow(b, a);
                        break;
                    default:
                        System.out.println("Invalid operator");
                        return;
                }
                stack.push(c);
            }
        }

        if (stack.size() == 1) {
            System.out.println("Output = " + stack.pop());
        } else {
            System.out.println("Invalid postfix expression");
        }

        scanner.close();
    }

    public static boolean isOperand(char ch) {
        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
    }

    public static boolean isOperator(char ch) {
        return ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%' || ch == '^';
    }
}

15. Infix to Prefix Notation:
------------------------------------------
 Write a java program to convert infix expression to prefix expression.
Infix: (a / b + c) - ( d + e * f) can be written as:

Step 1 – (/ab + c) - ( d + *ef)
Step 2 – Consider /ab and *ef as separate operand x and y
the innermost bracket now looks like (x + c) - (d + y)
Applying prefix it looks like – (+xc - +dy)replacing x and y here (+/abc - +d*ef)
Step 3 – Considering +/abc and+d*ef as separate operand z and w, the final bracket looks like – (z - w)the result would be -zw
           replacing z and w:
           Infix expression is = -+/abc+d*ef

ALgorithm to convert infix to prefix expression:
------------------------------------------------
Step 1: Reverse the infix string.
Step 2: Obtain the postfix expression of the infix expression Step 1.
Step 3: Reverse the postfix expression to get the prefix expression

TEST CASES:
------------------
case=t1
input=(a+b)*c
output=Prefix expression is : *+abc

case=t2
input=a+b*c/d-f+a^e
output=Prefix expression is: +a-*b/cd+f^ae


case=t3
fail message="hidden test case"
input=(a+B-E)+{1-]
output=Invalid Infix Expression-Different parenthesis in expression

case=t4
input=(a+b
output=Invalid Infix Expression - missing close parenthesis

case=t5
input=a+b)
output=Invalid Infix Expression - missing open parenthesis

case=t6
input=(a+b)-(c*d)
output=Prefix expression is : -+ab*cd 

case=t7
input=(a+b)-c*d)
output=Invalid Infix Expression - missing open parenthesis

case=t8
input=(a+b-)
output=Invalid Infix Expression - operators and operands do not match

case=t9
input=(a+b}
output=Invalid Infix Expression - Different parenthesis in expression

case=t10
fail message="hidden test case check operator and operand count"
input=(a+b--c)
output=Invalid Infix Expression - operators and operands do not match 

case=t11
input=(a/b+c)-(d+e*f)
output=Prefix expression is: -+/abc+d*ef

PROGRAM:
---------------------------------
import java.util.Scanner;
import java.util.Stack;

public class Main {
    static final int MAX = 20;
    static char[] stack = new char[MAX];
    static int top = -1;
    static String infix;
    static StringBuilder prefix = new StringBuilder();

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the infix expression: ");
        infix = scanner.next();

        reverseString(infix);
        int flag = toPrefix(infix);

        if (flag == 1) {
            reverseString(prefix.toString());
            System.out.println("Prefix expression is: " + prefix);
        } else {
            System.out.println("Invalid Infix Expression - operators and operands do not match");
            System.exit(0);
        }
        scanner.close();
    }

    static int toPrefix(String infix) {
        char ch;
        int operatorCount = 0;
        int operandCount = 0;

        for (int i = 0; i < infix.length(); i++) {
            ch = infix.charAt(i);
            if (ch == ')') {
                push(ch);
            } else if (Character.isLetterOrDigit(ch)) {
                operandCount++;
                prefix.append(ch);
            } else if (ch == '^' || ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%') {
                operatorCount++;
                while (top != -1 && getPriority(stack[top]) >= getPriority(ch)) {
                    prefix.append(pop());
                }
                push(ch);
            } else if (ch == '(') {
                while (top != -1 && stack[top] != ')') {
                    prefix.append(pop());
                }
                if (top != -1) {
                    pop(); // Remove the ')'
                } else {
                    System.out.println("Invalid Infix Expression - missing close parenthesis");
                    System.exit(0); // Invalid expression due to unmatched parentheses
                }
            } else {
                System.out.println("Invalid Infix Expression - Different parenthesis in expression");
                 System.exit(0);
            }
        }

        while (top != -1) {
            ch = pop();
            if (ch == ')') {
                System.out.println("Invalid Infix Expression - Missing open parenthesis");
               System.exit(0);
            }
            prefix.append(ch);
        }

        if (operatorCount == operandCount - 1) {
            return 1; // Valid expression
        } else {
            return 0; // Invalid expression
        }
    }

    static void push(char element) {
        if (top == MAX - 1) {
            System.out.println("Stack overflow");
        } else {
            stack[++top] = element;
        }
    }

    static char pop() {
        if (top == -1) {
            System.out.println("Invalid Infix Expression - Missing close parenthesis");
            System.exit(0);
        } 
            return stack[top--];
        
    }

    static int getPriority(char op) {
        if (op == '^') return 2;
        if (op == '/' || op == '*' || op == '%') return 1;
        if (op == '+' || op == '-') return 0;
        return -1;
    }

    static void reverseString(String str) {
        StringBuilder reversed = new StringBuilder(str).reverse();
        if (str.equals(infix)) {
            infix = reversed.toString();
        } else {
            prefix = reversed;
        }
    }
}


